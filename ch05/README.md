# Chap05. V8引擎

V8引擎是Node的心臟，它為Node撰寫可擴充的高性能伺服器提供了基本動力。本章探討它的特性以及這些特性對程式的影響做一個深入探討。了解這些，有助於避開錯誤，提升程式執行效率。

## JavaScript程式的編譯與最佳化

Node可以看作是JavaScript的執行時期環境。一方面，它提供了多種可呼叫的API，如讀寫檔案、網路請求、系統資訊等。另一方面，因為CPU執行的是機器碼，它還負責將JavaScript程式解釋成機器指令序列執行，這部分工作是由V8引擎完成。V8引擎是Node的心臟，其誕生之初的目標，就是**加強指令稿的執行效率**，它甚至直接將程式編譯為本機機器碼，以節省一般指令碼語言解釋執行的時間。

### 即時編譯

V8採用即時編譯技術(JIT)，直接將JavaScript程式編譯成本地平台的機器碼。巨觀上看，其步驟為JavaScript原始程式->抽象語法樹->本機機器碼，並且後一個步驟只依賴前一個步驟。這與其他解譯器不同，例如Java語言須先將原始程式編譯成位元組碼，然後給JVM解釋執行，JVM根據最佳化策略，執行過程中有選擇地將一部分位元組碼編譯成本地機器碼。V8不產生中間程式，過程如下：

JavaScript source code -> 抽象語法樹 -> 機器指令

V8設計之初，是加快Chrome瀏覽器執行網頁尾本的效率，當網頁載入完成，V8一步合格，編譯成機器碼，CPU就開始執行了。比起產生中間碼解釋執行的方式，V8的策略省去一個步驟，程式會更早地開始執行。並且執行編譯好的機器指令，也比解釋執行中間碼的速度更快。不足的事，**缺少位元碼這個中間表示**，**使得程式最佳化變得更困難**。

### 隱藏類別

類別是被熟知的概念，這裡加上「隱藏」兩字修飾，我們可以先考慮，什麼是不隱藏的類別。那應該是C++/Java這種靜態類型語言中，開發者定義的類別。這些靜態類型語言的每一個變數，都有一個唯一確定的類型。因為有類型資訊，一個物件包含哪些成員和這些成員在物件中的偏移量等資訊，編譯階段就可確定，即時執行CPU只需要用物件起始位址——C++中是this指標，加上成員在物件內部的偏移量即可存取內部成員。這些存取指令在編譯階段就產生了。

但對於JavaScript這種動態語言，變數在執行時期可以隨時由不同類型的物件設定值，並且物件本身可以隨時增刪成員。**存取物件屬性需要的資訊完全由執行時期決定**。為了實現按照索引的方式存取成員，V8「悄悄地」給執行中的物件分了類別，在這個過程中產生了一種**V8內部的資料結構**，即**隱藏類別**。**隱藏類別本身是一個物件**。

當定義一個建置函數，使用這個函數產生第一個物件的時候，V8會為它初始化一個隱藏類別。以後使用這個建置函數產生的物件指在同一個隱藏類別。但假如程式中對某個物件增加或刪除某些屬性，V8立即建立一個新的隱藏類別，改變之後的物件指向新建立的隱藏類別。

可見，隱藏類別造成給物件分組的作用。同一組的物件，具有相同的成員名稱。隱藏類別紀錄了成員名稱和偏移量，根據這些資訊，V8能夠按照物件起始位址＋偏移量存取成員變數。在程式中，存取物件成員是非常頻繁的操作，相比於把屬性名稱作為鍵值，使用字典尋找的方式存取成員，使用索引的方式對效能的改進更明顯。

### 內聯快取

借助隱藏類別，可以使用陣列索引的方式存取物件成員。但成員的索引值是以雜湊表的方式儲存在隱藏類別中。如果每次存取屬性都搜尋隱藏類別的雜湊表，那麼這個使用偏移量的方式不會帶來任何好處。內聯快取是以程式執行為基礎的局部性原理，動態產生使用索引尋找的程式。下一次存取成員就不必再去搜尋雜湊表。可以用兩段虛擬程式碼描述這個過程：

```c++
Object* find_name_general(Person* p) {
    Class* hidden_class = p->get_class();
    int offset = hidden_class->lookup_offset("name");
    update_cache(hidden_class, offset);
    return p->properties[offset];
}
Object* find_name_fast(Person* p) {
    if (Cached == p->get_class()) {
        // 內聯程式，直接使用快取結果
        return p->properties[CACHE_OFFSET];
    }else{
        return p->get_class()->lookup_offset("name");
    }
}
```

### 最佳化回復

V8為了進一步提升JavaScript程式的執行效率，使用了Crankshaft編譯器產生更高效的機器碼。程式在執行時期，V8會擷取JavaScript程式執行資料。當V8發現某函數執行頻繁，就將其標記為熱點函數。針對熱點函數，V8的策略較為樂觀，偏好認為此函數比較穩定，類型已經確定，於是呼叫Crankshaft編譯器，產生更高效的機器碼。後面的執行中，萬一遇到類型變化，V8採取將JavaScript函數回復到最佳化前的較一般的狀況。

```js
function add(a, b) {
  return a + b;
}
for (var i = 0; i < 10000; ++i) {
    add(i, i);
}
add('a', 'b');
```

上述程式在執行for循環的過程中，每次呼叫add()函數，傳入的參數是整數，執行一定次數後，V8可能把這個函數標記為熱點函數，並根據每次執行傳入的參數預測，此函數的參數a,
b為整數。於是呼叫Crankshaft編譯器產生對應的程式。但當循環退出，執行字串相加時，V8只好將函數回復到一般狀態。回復過程就是根據函數原始程式，產生對應的語法樹，然後編譯成一般形式的機器碼。可以預見這個過程是比較耗時的，並且放棄了最佳化後的程式去執行一般形式的程式，因此要盡量避免觸發。

### 寫出更具親和性的程式

以上討論V8的一些特性。根據這些知識，在程式中，應該盡量避免一些錯誤，使得程式在V8環境中執行效能表現得更好。

```js
// 片段一
var person = {
    add: function(a, b) {
      return a + b;
    }
};
person.name = 'li';
// 片段二
var person = {
    add: function(a, b) {
      return a + b;
    },
    name: 'li',
};
```

使用片段二的方式效率更高。片段一會造成隱藏類別的衍生。替物件動態地增加和刪除屬性都會衍生新的隱藏類別。假如物件的add函數已經被最佳化，產生了更高效的程式，則因為增加或刪除屬性，這個改變後的物件無法使用最佳化後的程式。

最佳化回復的實例也啟示我們，函數內部的參數類型越確定，V8越能夠產生最佳化後的程式。我們也要避免最佳化回復，例如可以再撰寫一個專門針對字串相加的函數，而非一個函數同時處理整數和字串。

### 借助TypeScript

JavaScript的動態、弱型別語言，擁有極大的靈活性。但這種靈活性很有可能要付出一些代價，為避免效能的損失，不妨對自己提出更高的要求。方法之一就是可以透過更嚴格的編碼標準，最好能從語法上強制程式符合某種契約，只有符合這種語法規則的檔案才能正常使用，來實現語言等級的最佳化。這樣做不僅能加強V8執行的效率，也使專案在變大的時候仍具備良好的可維護性。

TypeScript是微軟推出的JavaScript超集合。TypeScript完全相容JavaScript語法。因此使用它沒有任何門檻。但它增加了一些增強的語法，例如可定義強類型。類型不符合就無法編譯成功。TypeScript的ts檔執行前，需編譯成一般的JavaScript檔案，而編譯使得任何的語法錯誤可以被提前發現。例如可以定義一個相加函數，只接受數值型的參數。

```ts
"use strict";

function sum(x:number, y:number):number {
    return x + y;
}

console.log(sum(5, 8));
console.log(sum('1', 2)); // 無法編譯成功- 'string' is not assignable to parameter of type 'number'
```

可使用TypeScript介面的語法，使這種動態增加無法編譯成功：

```ts
"use strict";
interface SquareConfig {
    color: string,
    width: number,
}
// ok
let Square: SquareConfig = {color: 'black', width: 20};

// 編譯顯示出錯
let Square1: SquareConfig = {color: 'black', width: 20, height: 20};

// 編譯顯示出錯
Square.height = 20;
```

關於TypeScript更多內容：[https://tslang.cn/docs/home.html](https://tslang.cn/docs/home.html)

編譯ts檔案，需要先安裝對應的編譯器，在專案的根目錄下，執行：

```sh
yarn add typescript gulp gulp-typescript -D
```

_gulpfile.js_：

```js
var gulp = require("gulp");
var ts = require('gulp-typescript');

gulp.task('ts', function () {
    return gulp.src('./ts/**/*.ts')
        .pipe(ts({
            noImplicitAny: true,
            target: 'ES6'
        }))
        .pipe(gulp.dest('./'));
});
gulp.task('default', ['ts']);
```

然後執行`gulp`，就可以將ts資料夾內的ts檔案編譯為普通的JavaScript檔案。

## 垃圾回收與記憶體控制

### V8的垃圾回收演算法

JavaScript的物件在V8引擎的堆中建立，V8會自動回收不被參考的物件。採用這種方式，降低了記憶體管理的負擔，但也造成了一些不便，例如V8堆積記憶體大小的限制。在32位元系統上限制為0.7GB，64位元為1.4GB。之所以存在這種限制，根源在於垃圾回收演算法的限制。V8在執行垃圾回收的時候會阻塞JavaScript程式的執行，堆積記憶體過大導致回收演算法執行時間過長。「魚和熊掌不可兼得」，有垃圾回收的地方，都會存在堆大小的限制，Java也存在堆溢位的錯誤。

從巨觀上來看，V8的堆分為3部分，分別是**年輕分代**、**年老分代**、**大物件空間**。這三者儲存不同種類的物件。

#### 1. 年輕分代

年輕分代的堆積空間一分為二，只有一半處於使用中，另外一半用於垃圾清理。年輕分代主要儲存於那些生命期短暫的物件，例如函數中的區域變數。它們類似C++中在堆疊上分配的物件，當函數傳回，呼叫堆疊中的區域變數都會被解構掉。V8瞭解記憶體的使用情況，當發現記憶體空間不夠，需要清理時，才進行回收。實際步驟是，將還被參考的物件複製到另一半的區域，然後釋放目前一半的空間，把目前被釋放的空間留作備用，兩者角色互換。年輕分代類似執行緒的堆疊空間，本身不會太大，佔用它空間的物件類似C++中的局部物件，生命週期非常短，因此大部分都是需要被清理掉的，需要複製的物件極少，雖然犧牲了部分記憶體，但速度極快。

在C++程式中，當呼叫一個函數時，函數內部定義的局部物件會佔用堆疊空間，但函數巢狀結構總是有限的，隨著函數呼叫的結束，堆疊空間也被釋放掉。因此其執行過程中，堆疊猶如一個可伸長縮短的單眼鏡頭。而JavaScript程式的執行，因為物件使用的空間是在年輕分代中分配，當要在堆中分配而記憶體不夠時，由於新物件的擠壓，將超出生命期的垃圾物件清除出去，這個過程猶如在玩一種消除類遊戲。